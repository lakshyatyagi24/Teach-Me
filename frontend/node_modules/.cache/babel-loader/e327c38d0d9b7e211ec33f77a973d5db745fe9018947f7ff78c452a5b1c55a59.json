{"ast":null,"code":"// pass\nvar P = function (prototype, ownProperty, undefined) {\n  return function P(_superclass /* = Object */, definition) {\n    // handle the case where no superclass is given\n    if (definition === undefined) {\n      definition = _superclass;\n      _superclass = Object;\n    }\n\n    // C is the class to be returned.\n    //\n    // When called, creates and initializes an instance of C, unless\n    // `this` is already an instance of C, then just initializes `this`;\n    // either way, returns the instance of C that was initialized.\n    //\n    //  TODO: the Chrome inspector shows all created objects as `C`\n    //        rather than `Object`.  Setting the .name property seems to\n    //        have no effect.  Is there a way to override this behavior?\n    function C() {\n      var self = this instanceof C ? this : new Bare();\n      self.init.apply(self, arguments);\n      return self;\n    }\n\n    // C.Bare is a class with a noop constructor.  Its prototype will be\n    // the same as C, so that instances of C.Bare are instances of C.\n    // `new MyClass.Bare` then creates new instances of C without\n    // calling .init().\n    function Bare() {}\n    C.Bare = Bare;\n\n    // Extend the prototype chain: first use Bare to create an\n    // uninitialized instance of the superclass, then set up Bare\n    // to create instances of this class.\n    var _super = Bare[prototype] = _superclass[prototype];\n    var proto = Bare[prototype] = C[prototype] = C.p = new Bare();\n\n    // pre-declaring the iteration variable for the loop below to save\n    // a `var` keyword after minification\n    var key;\n\n    // set the constructor property on the prototype, for convenience\n    proto.constructor = C;\n    C.extend = function (def) {\n      return P(C, def);\n    };\n    return (C.open = function (def) {\n      if (typeof def === 'function') {\n        // call the defining function with all the arguments you need\n        // extensions captures the return value.\n        def = def.call(C, proto, _super, C, _superclass);\n      }\n\n      // ...and extend it\n      if (typeof def === 'object') {\n        for (key in def) {\n          if (ownProperty.call(def, key)) {\n            proto[key] = def[key];\n          }\n        }\n      }\n\n      // if no init, assume we're inheriting from a non-Pjs class, so\n      // default to using the superclass constructor.\n      if (!('init' in proto)) proto.init = _superclass;\n      return C;\n    })(definition);\n  };\n\n  // as a minifier optimization, we've closured in a few helper functions\n  // and the string 'prototype' (C[p] is much shorter than C.prototype)\n}('prototype', {}.hasOwnProperty);\nexports.P = P;","map":{"version":3,"names":["P","prototype","ownProperty","undefined","_superclass","definition","Object","C","self","Bare","init","apply","arguments","_super","proto","p","key","constructor","extend","def","open","call","hasOwnProperty","exports"],"sources":["C:/Users/oreld/Downloads/Teach-Me/frontend/node_modules/pjs/build/p.commonjs.js"],"sourcesContent":["// pass\nvar P = (function(prototype, ownProperty, undefined) {\n  return function P(_superclass /* = Object */, definition) {\n    // handle the case where no superclass is given\n    if (definition === undefined) {\n      definition = _superclass;\n      _superclass = Object;\n    }\n\n    // C is the class to be returned.\n    //\n    // When called, creates and initializes an instance of C, unless\n    // `this` is already an instance of C, then just initializes `this`;\n    // either way, returns the instance of C that was initialized.\n    //\n    //  TODO: the Chrome inspector shows all created objects as `C`\n    //        rather than `Object`.  Setting the .name property seems to\n    //        have no effect.  Is there a way to override this behavior?\n    function C() {\n      var self = this instanceof C ? this : new Bare;\n      self.init.apply(self, arguments);\n      return self;\n    }\n\n    // C.Bare is a class with a noop constructor.  Its prototype will be\n    // the same as C, so that instances of C.Bare are instances of C.\n    // `new MyClass.Bare` then creates new instances of C without\n    // calling .init().\n    function Bare() {}\n    C.Bare = Bare;\n\n    // Extend the prototype chain: first use Bare to create an\n    // uninitialized instance of the superclass, then set up Bare\n    // to create instances of this class.\n    var _super = Bare[prototype] = _superclass[prototype];\n    var proto = Bare[prototype] = C[prototype] = C.p = new Bare;\n\n    // pre-declaring the iteration variable for the loop below to save\n    // a `var` keyword after minification\n    var key;\n\n    // set the constructor property on the prototype, for convenience\n    proto.constructor = C;\n\n    C.extend = function(def) { return P(C, def); }\n\n    return (C.open = function(def) {\n      if (typeof def === 'function') {\n        // call the defining function with all the arguments you need\n        // extensions captures the return value.\n        def = def.call(C, proto, _super, C, _superclass);\n      }\n\n      // ...and extend it\n      if (typeof def === 'object') {\n        for (key in def) {\n          if (ownProperty.call(def, key)) {\n            proto[key] = def[key];\n          }\n        }\n      }\n\n      // if no init, assume we're inheriting from a non-Pjs class, so\n      // default to using the superclass constructor.\n      if (!('init' in proto)) proto.init = _superclass;\n\n      return C;\n    })(definition);\n  }\n\n  // as a minifier optimization, we've closured in a few helper functions\n  // and the string 'prototype' (C[p] is much shorter than C.prototype)\n})('prototype', ({}).hasOwnProperty);\nexports.P = P;\n"],"mappings":"AAAA;AACA,IAAIA,CAAC,GAAI,UAASC,SAAS,EAAEC,WAAW,EAAEC,SAAS,EAAE;EACnD,OAAO,SAASH,CAACA,CAACI,WAAW,CAAC,gBAAgBC,UAAU,EAAE;IACxD;IACA,IAAIA,UAAU,KAAKF,SAAS,EAAE;MAC5BE,UAAU,GAAGD,WAAW;MACxBA,WAAW,GAAGE,MAAM;IACtB;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,SAASC,CAACA,CAAA,EAAG;MACX,IAAIC,IAAI,GAAG,IAAI,YAAYD,CAAC,GAAG,IAAI,GAAG,IAAIE,IAAI,CAAD,CAAC;MAC9CD,IAAI,CAACE,IAAI,CAACC,KAAK,CAACH,IAAI,EAAEI,SAAS,CAAC;MAChC,OAAOJ,IAAI;IACb;;IAEA;IACA;IACA;IACA;IACA,SAASC,IAAIA,CAAA,EAAG,CAAC;IACjBF,CAAC,CAACE,IAAI,GAAGA,IAAI;;IAEb;IACA;IACA;IACA,IAAII,MAAM,GAAGJ,IAAI,CAACR,SAAS,CAAC,GAAGG,WAAW,CAACH,SAAS,CAAC;IACrD,IAAIa,KAAK,GAAGL,IAAI,CAACR,SAAS,CAAC,GAAGM,CAAC,CAACN,SAAS,CAAC,GAAGM,CAAC,CAACQ,CAAC,GAAG,IAAIN,IAAI,CAAD,CAAC;;IAE3D;IACA;IACA,IAAIO,GAAG;;IAEP;IACAF,KAAK,CAACG,WAAW,GAAGV,CAAC;IAErBA,CAAC,CAACW,MAAM,GAAG,UAASC,GAAG,EAAE;MAAE,OAAOnB,CAAC,CAACO,CAAC,EAAEY,GAAG,CAAC;IAAE,CAAC;IAE9C,OAAO,CAACZ,CAAC,CAACa,IAAI,GAAG,UAASD,GAAG,EAAE;MAC7B,IAAI,OAAOA,GAAG,KAAK,UAAU,EAAE;QAC7B;QACA;QACAA,GAAG,GAAGA,GAAG,CAACE,IAAI,CAACd,CAAC,EAAEO,KAAK,EAAED,MAAM,EAAEN,CAAC,EAAEH,WAAW,CAAC;MAClD;;MAEA;MACA,IAAI,OAAOe,GAAG,KAAK,QAAQ,EAAE;QAC3B,KAAKH,GAAG,IAAIG,GAAG,EAAE;UACf,IAAIjB,WAAW,CAACmB,IAAI,CAACF,GAAG,EAAEH,GAAG,CAAC,EAAE;YAC9BF,KAAK,CAACE,GAAG,CAAC,GAAGG,GAAG,CAACH,GAAG,CAAC;UACvB;QACF;MACF;;MAEA;MACA;MACA,IAAI,EAAE,MAAM,IAAIF,KAAK,CAAC,EAAEA,KAAK,CAACJ,IAAI,GAAGN,WAAW;MAEhD,OAAOG,CAAC;IACV,CAAC,EAAEF,UAAU,CAAC;EAChB,CAAC;;EAED;EACA;AACF,CAAC,CAAE,WAAW,EAAG,CAAC,CAAC,CAAEiB,cAAc,CAAC;AACpCC,OAAO,CAACvB,CAAC,GAAGA,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}